---
title: "mothur pre-process"
author: "Jakob Vucelic-Frick"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(patchwork)
library(cowplot)
#library(phylotools)
#library(biomformat)
```
toLatex(sessionInfo()) for session info
## Read in Final FASTA File

```{r funxUsedToProcess_mothurFiles}

#function to select abundant seqs
selectAbundantSeqs <- function(sample, abundCutoff){
  #determine the number of reads in the sample
  nReads <- sum(sample[,2])

  # determine relative abundance and return those above threshold
  relAbundance <- sample[,2]/nReads
  sample <- cbind(sample, relAbundance)
  colnames(sample)[3] <- "relAbund"
  return(sample[sample$relAbund >= abundCutoff,])
}

#function to process shared files
filterSharedFile <- function(sharedFile, minRelAbund, seqType){
  # find each ASC/OTU's count, calc relative abundance, and filter those < 1% abundance 
  sharedFile <- pivot_longer(sharedFile, cols=starts_with(seqType))
  sharedFile <- pivot_wider(sharedFile, names_from = "Group")
  
  #find indcies of singletons and non singletons and extract from df
  nonSingleton <- c()
  singleton <- c()
  for (i in 1:nrow(sharedFile)){
    if ((length(which(sharedFile[i,4:ncol(sharedFile)] == 0)) == (length(4:ncol(sharedFile)) -  1)) &
        (length(which(sharedFile[i,4:ncol(sharedFile)] == 1)) == 1)){
      singleton <- append(singleton, i)
    }
    else {
      nonSingleton <- append(nonSingleton, i)
    }
  }
  singletonAndNonSingletons <- list(nonSingletons = sharedFile[nonSingleton,], 
                                    singletons = sharedFile[singleton,])
  
  #extract a list of ASVs/OTUs from each sample based on abundance cutoff
  
  sampleSeqs <- list()
  for (i in 4:ncol(sharedFile)){
    #pass ASV/OTU IDs and the sample's reads
    selectedSeqs <- selectAbundantSeqs(sharedFile[nonSingleton,c(3,i)], minRelAbund)
    sampleSeqs[[colnames(sharedFile)[i]]] <- list(seqs = selectedSeqs, totalCoverage = sum(selectedSeqs$relAbund))
  }
  
  sampleSeqs$rawData <- singletonAndNonSingletons
  #to test !!!
  return(sampleSeqs)
}

#function to write fasta to file
writeFasta <- function(dfFasta, outputFileName){
  cat(paste0(">",dfFasta$seq.name[1], "\n", dfFasta$seq.text[1]), 
    file=outputFileName, append=FALSE)

  for (i in 2:nrow(dfFasta)){
    cat(paste0("\n>",dfFasta$seq.name[i], "\n", dfFasta$seq.text[i]), 
        append=TRUE,
        file=outputFileName)
  }

}

#function to extract the unique ASV/OTU IDs from a list (also possible to extract the community abundance observed)
extractSeqsOfInterest <- function(seqData){
  tempVec <- c()
  for (sample in setdiff(names(seqData), "rawData")){
    tempVec <- append(tempVec, seqData[[sample]]$seqs$name)
  }
  return(unique(tempVec))
}

# function to determine the sequence ID corresponding to the OTU/ASVs
getSeqIDs <- function(listFile, seqsOfInterest, seqType){
  seqList <- pivot_longer(read.delim(file=listFile, header=TRUE, sep="\t"),
                        cols=starts_with(seqType))
  seqIDs <-  seqList %>%
    filter(name %in% seqsOfInterest) %>%
    pull(value) %>%
    str_split(",") %>%
    unlist
  
  return(seqIDs)
}

# function to make a biom file (to add meta data later)
writeBIOM <- function(sharedFile, seqsOfInterest, typeOfSeq, outputBIOM, sampleMD = NULL, obsMD = NULL){
  biomInfo <- sharedFile%>%
  select(c("Group",contains(typeOfSeq))) %>%
  select(Group, all_of(seqsOfInterest)) %>%
  column_to_rownames("Group") %>%
  t() %>%
  as.data.frame()
  
  biomFile <- make_biom(data=biomInfo, sample_metadata = sampleMD, observation_metadata = obsMD, id = NULL, matrix_element_type = "int")

  #return(biomFile)
  write_biom(biomFile, outputBIOM)

}

```

```{r funxToProcessPICRUST2}
getCazyFiles <- function(picrustDir, cazyOfInterest = NULL){
  
  picrustInfo <- list()
  for(dir in picrustDir){
    contribFile <- read.table(gzfile(paste0(dir, "/CAZY_metagenome_out/pred_metagenome_contrib.tsv.gz")), header = TRUE)
    unstratFile <- read.table(gzfile(paste0(dir, "/CAZY_metagenome_out/pred_metagenome_unstrat.tsv.gz")), header = TRUE)
    seqTabs <- read.table(gzfile(paste0(dir, "/CAZY_metagenome_out/seqtab_norm.tsv.gz")), header = TRUE)
    wnsti <- read.table(gzfile(paste0(dir, "/CAZY_metagenome_out/weighted_nsti.tsv.gz")), header = TRUE)
    nsti <- read.table(gzfile(paste0(dir, "/combined_marker_predicted_and_nsti.tsv.gz")), header = TRUE)
    
    if (!is.null(cazyOfInterest)){
      contribFile <- contribFile[contribFile$function. %in% cazyOfInterest,]
      unstratFile <- unstratFile[unstratFile$function. %in% cazyOfInterest,]
    }
    
    
    picrustInfo[[dir]] <- list(contrib = contribFile,
                                 unstrat = unstratFile,
                                 seqTabs = seqTabs,
                                 weighted_nsti= wnsti,
                                 asv_nsti = nsti)
  }
  return(picrustInfo)
}

processNsti <- function(cazyList){
  # Initialize empty data frame to collect all NSTI values
  nsti_all <- data.frame()
  nsti_all_weighted <- data.frame()
  
  # Loop through each experiment in the list
  for (experiment in names(cazyList)) {
    
    # Extract the NSTI table for this experiment
    nsti_table <- cazyList[[experiment]]$asv_nsti
    weighted_nsti_table <- cazyList[[experiment]]$weighted_nsti
    
    # Add experiment name as a new column
    nsti_table$Experiment <- experiment
    weighted_nsti_table$Experiment <- experiment
    
    # Append to combined dataframe
    nsti_all <- bind_rows(nsti_all, nsti_table[, c("metadata_NSTI", "Experiment")])
    nsti_all_weighted <- bind_rows(nsti_all_weighted, weighted_nsti_table[, c("weighted_NSTI", "Experiment")])

  }
  
  # Plot NSTI histogram faceted by experiment
  nstiBox_asv <- ggplot(nsti_all, aes(x = Experiment, y =metadata_NSTI, fill= Experiment)) +
    geom_boxplot() +
    scale_y_continuous(limits = c(0, 2), breaks = seq(0, 2, by = 0.1)) +
    theme_classic() +
    labs(title = "Distribution of NSTI Values per Experiment",
         x = "NSTI",
         y = "Count")
  
  nstiBox_weighted <- ggplot(nsti_all_weighted, aes(x = Experiment, y =weighted_NSTI, fill= Experiment)) +
    geom_boxplot() +
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.05)) +
    theme_classic() +
    labs(title = "Distribution of Weighted NSTI Values per Experiment",
         x = "NSTI",
         y = "Count")
  
  return(list(nstiBox_asv = nstiBox_asv,
              nstiBox_weighted = nstiBox_weighted,
              nstiTable = nsti_all,
              weightedNstiTable = nsti_all_weighted))
}



#function to merge unstrat tables from a list of picrust output
mergeUnstrat <- function(listOfExps){
  listOfUnstrat <- list()
  for(exp in names(listOfExps)){
    listOfUnstrat[[str_split(exp, "_p")[[1]][1]]] <- listOfExps[[exp]]$unstrat
  }
  merged_unstrat <- reduce(
  listOfUnstrat,
  full_join,
  by = "function.")
  merged_unstrat[is.na(merged_unstrat)] <- 0

  return(merged_unstrat)
}
```


# Comparing Diversity Measurements
```{r loadData}
# aggergate the alpha diversity metrics from each experiment, removing rows with nseqs = 0
dataDirs <- c("PRJEB20299", "PRJNA309354", "PRJEB27872", "PRJNA494847")

dfAlphaDiv <- data.frame()
for (dir in dataDirs){
  dfAlphaDiv <- rbind(read_delim(file = paste0("../mothur/", dir,"/output/final.opti_mcc.0.03.subsample.groups.ave-std.summary"), delim="\t"),dfAlphaDiv)
}
dfAlphaDiv <- dfAlphaDiv[dfAlphaDiv$nseqs > 0, ]

#dfAlphaDiv <- read.csv(file="alphaDiversityMetrics.csv")

# load in the metadata
metadata <- read_delim(file="metadata_1.tsv") %>% 
  mutate_all(as.factor)
dfAlphaDiv <- cbind(dfAlphaDiv, metadata)



# write/read merged data
write.csv(dfAlphaDiv, file = "alphaDiversityMetrics_withMetadata.csv")
dfAlphaDiv <- read_csv("alphaDiversityMetrics_withMetadata.csv")

# set factors
dfAlphaDiv$rettingPeriod <- factor(dfAlphaDiv$rettingPeriod, levels = paste0("R", 0:100))

dfAlphaDiv$treatment <- factor(dfAlphaDiv$treatment, levels = c("early harvest", "standard harvest", "High Moisture", "Low Moisture", "Soil Slurry", "inoculated", "standard"))
dfAlphaDiv$stage <- factor(dfAlphaDiv$stage, levels = c("early","middle", "late"))
dfAlphaDiv$turned <- factor(dfAlphaDiv$turned, levels = c("FALSE","TRUE", "na"))

```

```{r coverage}
# summarize the experiments (coverage and summary)

summarise_exps <- function(dirs,df){
  
  tempList <- list()

  for(accID in dirs){
      tempList[[accID]] <- quantile(df[df$experiment == accID, "coverage"], probs = 0.025, na.rm = TRUE)
  }
  return(tempList)
}


listSummaries <- summarise_exps(dataDirs, dfAlphaDiv)

```

# Plot Alpha Diversity
```{r bespokeFunx}

# create a unique replicate ID for coloring
dfAlphaDiv$group_id <- interaction(dfAlphaDiv$replicate, dfAlphaDiv$cultivar_type, dfAlphaDiv$treatment, drop = TRUE)

dfAlphaDiv <- dfAlphaDiv %>%
  mutate(rettingPeriodNum = as.numeric(gsub("R", "", rettingPeriod)))


# function to plot smoothed scatter plot
plotAlphaDiv <- function(df, estimator, lci=NULL, hci=NULL, title, yax, xax, accID = "", turningPoint) {
  
  p <- ggplot(df, aes(x = rettingPeriod, y = !!sym(estimator)))
  
  if (!is.null(lci) && !is.null(hci)) {
    p <- p + geom_errorbar(aes(
      ymin = !!sym(lci),
      ymax = !!sym(hci),
      group = group_id,
      color = cultivar_type
    ), width = 0.3)
  }
    
    
  n_cultivars <- length(unique(df$cultivar_type))

  # Base plot
  p <- ggplot(df, aes(x = rettingPeriod, y = !!sym(estimator))) +
    geom_vline(xintercept = turningPoint, 
               linetype = "dashed", 
               color = "grey40")
  
  # Conditional aesthetics
  if (n_cultivars > 1) {
    p <- p +
      geom_point(aes(color = cultivar_type), size = 2) +
      geom_line(aes(group = group_id, color = cultivar_type), linewidth = 0.8, alpha = 0.8) +
      geom_smooth(aes(group = treatment, color = cultivar_type),
                  span = 0.6, method = "loess", se = FALSE,
                  color = "#6F23B5", linetype = "dotdash", linewidth = 0.8)
  } else {
    p <- p +
      geom_point(size = 2, color = "black") +
      geom_line(aes(group = group_id), linewidth = 0.8, alpha = 0.8, color = "black") +
      geom_smooth(aes(group = treatment),
                  span = 0.6, method = "loess", se = FALSE,
                  color = "#6F23B5", linetype = "dotdash", linewidth = 0.8)
  }
  
  # Add the rest of the formatting
  p <- p +
    facet_wrap(~ treatment) +
    labs(
      title = paste0(title, " (", accID, ")"),
      x = xax,
      y = yax,
      color = if (n_cultivars > 1) "Cultivar" else NULL
    ) +
    theme_classic() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 15),
      axis.text.y = element_text(size = 15),
      axis.title.x = element_text(size = 19),
      axis.title.y = element_text(size = 19),
      legend.text = element_text(size = 18),
      legend.title = element_text(size = 20),
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
      strip.text = element_text(size = 18, face = "bold"),
      legend.position = if (n_cultivars > 1) "right" else "none"
    ) +
    scale_x_discrete(breaks = function(x) x[seq(1, length(x), by = 2)])+
    coord_cartesian(expand = FALSE)
}

listOfAlphaPlots <- list()
```

```{r mothur_AlphaDiv_PRJEB20299}
# Filter for the experiment
dfTemp <- dfAlphaDiv %>% filter(experiment == "PRJEB20299") 

#plot alpha-diversity estimators
listOfAlphaPlots$PRJEB20299$shannon <- plotAlphaDiv(
  df = dfTemp,
  estimator = "shannon",
  lci = "shannon_lci",
  hci = "shannon_hci",
  title = "Shannon Diversity by Retting Period",
  yax = "Shannon Diversity Index",
  xax = "Retting Period",
  accID = "PRJEB20299",
  turningPoint = 4
)

listOfAlphaPlots$PRJEB20299$heip <- plotAlphaDiv(
  df = dfTemp,
  estimator = "heip",
  title = "Heip's Metric of Evenness by Retting Period",
  yax = "Heip Metric",
  xax = "Retting Period",
  accID = "PRJEB20299",
  turningPoint = 4
)

listOfAlphaPlots$PRJEB20299$chao <- plotAlphaDiv(
  df = dfTemp,
  estimator = "chao",
  lci = "chao_lci",
  hci = "chao_hci",
  title = "Chao1 Estimator by Retting Period",
  yax = "Chao1 Estimator",
  xax = "Retting Period",
  accID = "PRJEB20299",
  turningPoint = 4
)

listOfAlphaPlots$PRJEB20299$invsimpson <- plotAlphaDiv(
  df = dfTemp,
  estimator = "invsimpson",
  lci = "invsimpson_lci",
  hci = "invsimpson_hci",
  title = "Inverse Simpson Index by Retting Period",
  yax = "Inverse Simpson Index",
  xax = "Retting Period",
  accID = "PRJEB20299",
  turningPoint = 4
)

```

```{r mothur_AlphaDiv_PRJNA309354}
# Filter for the experiment
dfTemp <- dfAlphaDiv %>% filter(experiment == "PRJNA309354") 

#plot alpha-diversity estimators
listOfAlphaPlots$PRJNA309354$shannon <- plotAlphaDiv(
  df = dfTemp,
  estimator = "shannon",
  lci = "shannon_lci",
  hci = "shannon_hci",
  title = "Shannon Diversity by Retting Period",
  yax = "Shannon Diversity Index",
  xax = "Retting Period",
  accID = "PRJNA309354",
  turningPoint = 0
)

listOfAlphaPlots$PRJNA309354$heip <- plotAlphaDiv(
  df = dfTemp,
  estimator = "heip",
  title = "Heip's Metric of Evenness by Retting Period",
  yax = "Heip Metric",
  xax = "Retting Period",
  accID = "PRJNA309354",
  turningPoint = 0
)

listOfAlphaPlots$PRJNA309354$chao <- plotAlphaDiv(
  df = dfTemp,
  estimator = "chao",
  lci = "chao_lci",
  hci = "chao_hci",
  title = "Chao1 Estimator by Retting Period",
  yax = "Chao1 Estimator",
  xax = "Retting Period",
  accID = "PRJNA309354",
  turningPoint = 0
)

listOfAlphaPlots$PRJNA309354$invsimpson <- plotAlphaDiv(
  df = dfTemp,
  estimator = "invsimpson",
  lci = "invsimpson_lci",
  hci = "invsimpson_hci",
  title = "Inverse Simpson Index by Retting Period",
  yax = "Inverse Simpson Index",
  xax = "Retting Period",
  accID = "PRJNA309354",
  turningPoint = 0
)


```

```{r mothur_AlphaDiv_PRJEB27872}
# Filter for the experiment
dfTemp <- dfAlphaDiv %>% filter(experiment == "PRJEB27872") 

#plot alpha-diversity estimators
listOfAlphaPlots$PRJEB27872$shannon <- plotAlphaDiv(
  df = dfTemp,
  estimator = "shannon",
  lci = "shannon_lci",
  hci = "shannon_hci",
  title = "Shannon Diversity by Retting Period",
  yax = "Shannon Diversity Index",
  xax = "Retting Period",
  accID = "PRJEB27872",
  turningPoint = 6
)

listOfAlphaPlots$PRJEB27872$heip <- plotAlphaDiv(
  df = dfTemp,
  estimator = "heip",
  title = "Heip's Metric of Evenness by Retting Period",
  yax = "Heip Metric",
  xax = "Retting Period",
  accID = "PRJEB27872",
  turningPoint = 6
)


listOfAlphaPlots$PRJEB27872$chao <- plotAlphaDiv(
  df = dfTemp,
  estimator = "chao",
  lci = "chao_lci",
  hci = "chao_hci",
  title = "Chao1 Estimator by Retting Period",
  yax = "Chao1 Estimator",
  xax = "Retting Period",
  accID = "PRJEB27872",
  turningPoint = 6
)

listOfAlphaPlots$PRJEB27872$invsimpson <- plotAlphaDiv(
  df = dfTemp,
  estimator = "invsimpson",
  lci = "invsimpson_lci",
  hci = "invsimpson_hci",
  title = "Inverse Simpson Index by Retting Period",
  yax = "Inverse Simpson Index",
  xax = "Retting Period",
  accID = "PRJEB27872",
  turningPoint = 6
)

```

```{r mothur_AlphaDiv_AlphaDiv_PRJNA494847}
# Filter for the experiment
dfTemp <- dfAlphaDiv %>% filter(experiment == "PRJNA494847") 

#plot alpha-diversity estimators
listOfAlphaPlots$PRJNA494847$shannon <- plotAlphaDiv(
  df = dfTemp,
  estimator = "shannon",
  lci = "shannon_lci",
  hci = "shannon_hci",
  title = "Shannon Diversity by Retting Period",
  yax = "Shannon Diversity Index",
  xax = "Retting Period",
  accID = "PRJNA494847",
  turningPoint = 4
)

listOfAlphaPlots$PRJNA494847$heip <- plotAlphaDiv(
  df = dfTemp,
  estimator = "heip",
  title = "Heip's Metric of Evenness by Retting Period",
  yax = "Heip Metric",
  xax = "Retting Period",
  accID = "PRJNA494847",
  turningPoint = 4
)

listOfAlphaPlots$PRJNA494847$chao <- plotAlphaDiv(
  df = dfTemp,
  estimator = "chao",
  lci = "chao_lci",
  hci = "chao_hci",
  title = "Chao1 Estimator by Retting Period",
  yax = "Chao1 Estimator",
  xax = "Retting Period",
  accID = "PRJNA494847",
  turningPoint = 4
)

listOfAlphaPlots$PRJNA494847$invsimpson <- plotAlphaDiv(
  df = dfTemp,
  estimator = "invsimpson",
  lci = "invsimpson_lci",
  hci = "invsimpson_hci",
  title = "Inverse Simpson Index by Retting Period",
  yax = "Inverse Simpson Index",
  xax = "Retting Period",
  accID = "PRJNA494847",
  turningPoint = 4
)
```


```{r saveListOfAlphPlots}
# Loop through each experiment in your list of plots
for (exp in names(listOfAlphaPlots)) {
  
  # Create directory path
  dir_path <- file.path(".", exp, "alphaDivPlots")
  
  # Create the directory if it doesn't exist
  if (dir.exists(dir_path)) {
    unlink(dir_path, recursive = TRUE, force = TRUE)
  }
  dir.create(dir_path, recursive = TRUE)
  
  # Loop through each diversity metric plot in the experiment
  for (div_metric in names(listOfAlphaPlots[[exp]])) {
    
    plot_obj <- listOfAlphaPlots[[exp]][[div_metric]]
    
    # Define output filename
    file_name <- paste0(div_metric, "_", exp, ".png")
    file_path <- file.path(dir_path, file_name)
    
    # Save the plot
    ggsave(
      filename = file_path,
      plot = plot_obj,
      width = 12,
      height = 8,
      dpi = 800
    )
  }
}
```

# wilcox test different group combos
```{r statisticalAnalysis_sample}
wilcoxComparisons <- read_delim(file="wilcox_comparisons.tsv")
pValues <- c()
for(i in 1:nrow(wilcoxComparisons)){ 
  expID <- wilcoxComparisons[i,"experiment"][[1]]
  expDf <- dfAlphaDiv %>% 
    filter(experiment == expID)
  
  estimator <- wilcoxComparisons[i,"estimator"][[1]]
  group <- wilcoxComparisons[i,"group"][[1]]
  alternative <- wilcoxComparisons[i,"alternative"][[1]]
  
  dfFiltered <- expDf
  #filter for proper stage (if needed)
  if(wilcoxComparisons[i,"group"][[1]] == "stage"){
    dfFiltered <- dfFiltered[dfFiltered$stage %in% c(wilcoxComparisons[i,"filter1"][[1]],wilcoxComparisons[i,"filter2"][[1]]), ]
  }
  
  #filter for treatment
  if(!(wilcoxComparisons[i,"filter1"][[1]] == "na") & (wilcoxComparisons[i,"filter2"][[1]] == "na")){
    dfFiltered <- dfFiltered[dfFiltered$treatment == wilcoxComparisons[i,"filter1"][[1]],]
  }
  else if((wilcoxComparisons[i,"group"][[1]] == "treatment") & !(wilcoxComparisons[i,"filter2"][[1]] == "na")){
    dfFiltered <- dfFiltered[dfFiltered$treatment %in% c(wilcoxComparisons[i,"filter1"][[1]],wilcoxComparisons[i,"filter2"][[1]]), ]
  }
  
  #filter for filter 3 if needed
  if(!(wilcoxComparisons[i,"filter3"][[1]] == "na")){
    dfFiltered <- dfFiltered[dfFiltered$treatment == wilcoxComparisons[i,"filter3"][[1]],]
  }
  
  formula <- as.formula(paste(estimator, "~", group))
  
  p <- wilcox.test(formula = formula, alternative = alternative, data = dfFiltered)$p.value
  
  pValues <- append(pValues, p)
  
}
wilcoxComparisons$pVal <- pValues
write.csv(wilcoxComparisons, "wilcoxComparrisons_withSignificance.csv")

wilcoxFiltered <- wilcoxComparisons %>%
  filter(pVal <= 0.05)

```


# Get AMOVA and LEfSe data
```{r funxToReadAmovaToDF}
readAmova_mothur <- function(amovaFile){
  dfTemp <- data.frame()
  # Read lines
  lines <- readLines(amovaFile)  

  results <- list()
  i <- 1
  p <- 0
  while (i <= length(lines)) {
    parts <- strsplit(lines[i], "\t")[[1]]
    
    if (length(parts) > 1 && parts[2] == "Among") {
      comp <- parts[1]
      ss <- as.numeric(strsplit(lines[i+1], "\t")[[1]][2:4])
      df <- as.numeric(strsplit(lines[i+2], "\t")[[1]][2:4])
      ms <- as.numeric(strsplit(lines[i+3], "\t")[[1]][2:3])
      Fs <- as.numeric(strsplit(lines[i+5], ":")[[1]][2])
      p  <- strsplit(strsplit(lines[i+6], ":")[[1]][2], "\\*")[[1]][1]
      
      results[[length(results)+1]] <- data.frame(
        comparison = comp, ss_among = ss[1], ss_within = ss[2], ss_total = ss[3],
        df_among = df[1], df_within = df[2], df_total = df[3],
        ms_among = ms[1], ms_within = ms[2], Fs = Fs, p_value = p
      )
      i <- i + 6
    } else {
      i <- i + 1
    }
  }
  
  # Combine and view
  dfTemp <- do.call(rbind, results)
  return(dfTemp)
  
}
getwd()
dataDirs

#readAmova_mothur("../mothur/PRJNA494847/output/turned/final.opti_mcc.jclass.0.03.lt.ave.amova")
```

```{r fetchData_amova_LEfSe}
dfLefse <- data.frame()
dfAmova <- data.frame()
for (dir in dataDirs){
  
  statsDirs <- list.dirs(path = paste0("../mothur/",dir, "/output"), recursive = FALSE, full.names = FALSE)
  for(statsDir in statsDirs){
    statsFiles <- list.files(path = paste0("../mothur/",dir, "/output/",statsDir), full.names = TRUE)
    for(statsFile in statsFiles){
      matrixType <- sub(".*opti_mcc\\.(.*?)\\.0\\.03.*", "\\1", statsFile)
      if(grepl(pattern = "amova", x= statsFile, ignore.case = TRUE)){
        amovaDf <- readAmova_mothur(statsFile)
        amovaDf$exp <- dir
        amovaDf$class <- statsDir
        amovaDf$matrixType <- matrixType
        dfAmova <- rbind(amovaDf, dfAmova)
      }
      else if(grepl(pattern="lefse", x = statsFile, ignore.case = FALSE)){
        lefseDf <- read_delim(file= statsFile)
        names(lefseDf) <- c("OTU","LogMeanMax","Class","LDA","pValue")
        lefseDf$exp <- dir
        lefseDf$testingGroup <- statsDir
        dfLefse <- rbind(lefseDf,dfLefse)
      }
    }
    
  }
}

# divide the amova by matrix type
dfAmova <- dfAmova[order(dfAmova$comparison, decreasing = TRUE), ]
amovaYC <- dfAmova[dfAmova$matrixType == "thetayc",]
amovaJaccard <- dfAmova[dfAmova$matrixType == "jclass",]

#filter the lefse by significance
dfLefse_filtered <- dfLefse %>%
  filter(!is.na(LDA))

#write the amova and lefse data
write.csv(amovaJaccard, file = "amovaResults_jaccard_mothur.csv")
write.csv(amovaYC, file = "amovaResults_yueClayton_mothur.csv")
write.csv(dfLefse, file = "lefseResults.csv")

```


# analyze the amova generated from mothur
```{r analyzeAmova}
#filter amova, selected for yue clayton matrix
filteredAmova <- amovaYC %>%
  mutate(
    p_value = gsub(" ", "", p_value),                
    p_value = as.numeric(gsub("<", "", p_value)),        
    significance = case_when(
      p_value == 0.001 ~ "***",                          
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ "NS"                              
    )
  )

filteredAmova$p_value <- gsub("0.001", "<0.001", as.character(filteredAmova$p_value))
filteredAmova <- filteredAmova[filteredAmova$significance != "NS",]

```

# analyze the LEsFe generated by mothur
```{r}
dfLefse_filtered <- read.csv(file = "lefseResults.csv") %>%
  filter(!is.na(LDA))

#get genus level taxonomies for each otu
df_lefseWithTaxonomy <- data.frame()
for(experiment in dataDirs){
  mothurDir <- paste0("../mothur/",experiment, "/output/")
  otusToMerge <- unique(dfLefse_filtered[dfLefse_filtered$exp == experiment, "OTU"])
  
  #find taxonomy of different seq.names and merge with the significant otus while tracking the experiment
  otuSeqNames <- pivot_longer(read.delim(file=paste0(mothurDir,"final.opti_mcc.list"), header=TRUE, sep="\t"),
                      cols=starts_with("Otu")) %>%
    filter(name %in% otusToMerge) %>%
    select(name, seq.name = value) %>% 
    mutate(seq.name = strsplit(seq.name, ",")) %>%
    unnest(seq.name)
  
  seqTaxes <- read.delim(file=paste0(mothurDir,"final.taxonomy"), sep = "\t", header = F, col.names = c("seq.name","taxonomy")) %>%
    mutate(genus = sapply(strsplit(as.character(taxonomy), ";"), function(x) x[6]))
  
  lefseByGenus <- merge(otuSeqNames, seqTaxes) %>%
    filter(!duplicated(name)) %>%
    select(name, genus)
  lefseByGenus$experiment <- experiment
  
  # merge lefse with tax by experiment
  lefseNoTax <- dfLefse_filtered[dfLefse_filtered$exp == experiment, ]
  lefseByGenus <- merge(lefseNoTax, lefseByGenus, by.x = "OTU", by.y = "name") %>%
    filter(!grepl("Bacteria_unclassified*", genus))
  df_lefseWithTaxonomy <- rbind(df_lefseWithTaxonomy, lefseByGenus)
}

# write the significant LEfSe to csv
write.csv(df_lefseWithTaxonomy, file = "lefseSignificant_withTaxonomy.csv")
#df_lefseWithTaxonomy <- read.csv(file="lefseSignificant_withTaxonomy.csv")

df_lefseWithTaxonomy <- df_lefseWithTaxonomy %>%
  group_by(OTU, exp, testingGroup) %>%
  slice_min(pValue, with_ties = FALSE) %>%
  ungroup()

df_lefseWithTaxonomy$genus_noSig <- gsub("\\([0-9]+\\)", "", df_lefseWithTaxonomy$genus)
df_lefseWithTaxonomy$genus_noSig <- gsub("_", " ", df_lefseWithTaxonomy$genus_noSig)
df_lefseWithTaxonomy$genus_noSig <- gsub("unclassified", "(family)", df_lefseWithTaxonomy$genus_noSig)

df_lefseWithTaxonomy <- df_lefseWithTaxonomy %>%
  mutate(
    Class = case_when(
      grepl("early", Class, ignore.case = TRUE) & testingGroup == "treatment" ~ "Early Harvest",
      grepl("standard", Class, ignore.case = TRUE) & experiment == "PRJEB20299" ~ "Standard Harvest",
      grepl("standard", Class, ignore.case = TRUE) & experiment == "PRJNA309354" ~ "Water-retting",
      grepl("inoculated", Class, ignore.case = TRUE) & experiment == "PRJNA309354" ~ "Water-retting Inoculated",
      grepl("TRUE", Class) ~ "Post-turning",
      grepl("FALSE", Class) ~ "Pre-turning",
      !grepl("HM|LM|SS", Class) ~ str_to_title(Class),
      TRUE ~ Class  # fallback if no condition matched
    )
  ) %>%
  filter(!grepl("rettingPeriod", testingGroup, ignore.case = TRUE))

  


# find number of experiments per each genus–Class pair 
df_summary <- df_lefseWithTaxonomy %>%
  group_by(genus_noSig, Class, experiment) %>%
  summarise(meanLDA = mean(LDA, na.rm = TRUE), .groups = "drop")

# select top genera based on max meanLDA across all experiments (ie most significant)
top_genera <- df_summary %>%
  group_by(genus_noSig) %>%
  summarise(maxLDA = max(meanLDA, na.rm = TRUE)) %>%
  arrange(desc(maxLDA)) %>%
  slice_head(n = 15) %>%
  pull(genus_noSig)

df_filtered <- df_summary %>%
  filter(genus_noSig %in% top_genera)

# summarize each genus/Class pair appearence
shared_pairs <- df_filtered %>%
  distinct(genus_noSig, Class, experiment) %>%
  group_by(genus_noSig, Class) %>%
  summarise(num_experiments = n(), .groups = "drop")

# merge back the count into df_filtered
df_filtered <- df_filtered %>%
  left_join(shared_pairs, by = c("genus_noSig", "Class")) %>%
  mutate(num_experiments = replace_na(num_experiments, 0))

# set factor levels for Class
df_filtered$Class <- factor(df_filtered$Class, levels = c(
  "Early", "Middle", "Late",
  "Pre-Turning", "Post-Turning",
  "HM", "LM", "SS",
  "Early Harvest", "Standard Harvest",
  "Water-Retting", "Water-Retting Innoculated"
))

# plotting function with shapes for shared pairs
plot_heatmap <- function(df, experiment_name) {
  df_exp <- df %>%
    filter(experiment == experiment_name) %>%
    select(genus_noSig, Class, meanLDA, num_experiments)

  # Define factor levels per experiment
  if (experiment_name == "PRJEB20299") {
    factorLevels <- c("Early", "Middle", "Late",
                      "Pre-Turning", "Post-Turning",
                      "Early Harvest", "Standard Harvest")
  } else if (experiment_name == "PRJNA309354") {
    factorLevels <- c("Early", "Middle", "Late", 
                      "Water-Retting", "Water-Retting Innoculated")
  } else if (experiment_name == "PRJEB27872") {
    factorLevels <- c("Early", "Middle", "Late",
                      "Pre-Turning", "Post-Turning")
  } else if (experiment_name == "PRJNA494847") {
    factorLevels <- c("Early", "Middle", "Late",
                      "Pre-Turning", "Post-Turning",
                      "HM", "LM", "SS")
  }

  # fill in missing genus/Class combinations with 0
  df_exp <- df_exp %>%
    complete(genus_noSig = top_genera, Class,
             fill = list(meanLDA = 0, num_experiments = 0))

  # Consistent factor levels
  df_exp$genus_noSig <- factor(df_exp$genus_noSig, levels = top_genera)
  df_exp$Class <- factor(df_exp$Class, levels = factorLevels)
  df_exp <- df_exp %>% filter(!is.na(Class))

  ggplot(df_exp, aes(x = Class, y = genus_noSig, fill = meanLDA)) +
    geom_tile(color = "white") +
    # Add shape for shared genus Class pairs
    geom_point(
      data = filter(df_exp, num_experiments %in% c(2, 3)),
      aes(shape = as.factor(num_experiments)),
      color = "skyblue3",
      size = 6,  # Make this larger for visibility
      inherit.aes = TRUE,
      show.legend = TRUE) +
    # Define the shape mapping
    scale_shape_manual(
      values = c("2" = 17,  
                 "3" = 16, 
                 "4" = 8),
      name = "Shared Genera:",
      labels = c("2" = "2 Experiments", "3" = "3 Experiments")
    ) +

    scale_fill_gradient2(
      low = "#f7f7f7",   
      mid = "#feb24c", 
      high = "#b30000",
      midpoint = median(df_exp$meanLDA, na.rm = TRUE),
      name = "Effect Size (LDA)"
    ) +

    labs(title = paste0("Accession: ", experiment_name),
         x = "Experimental Subclass", y = "Genus") +
    theme_classic() +
    theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 22),
    axis.text.y = element_text(size = 22),
    axis.title.x = element_text(size = 25),
    axis.title.y = element_text(size = 25),
    legend.text = element_text(size = 26),
    legend.title = element_text(size = 30),
    plot.title = element_text(size = 26, face = "bold", hjust = 0.5),
    strip.text = element_text(size = 26, face = "bold"),
    legend.position = "right")
}


experiments <- unique(df_filtered$experiment)

plots <- lapply(experiments, function(exp) plot_heatmap(df_filtered, exp))


plots[[1]] <- plots[[1]] + theme(legend.position = "right")

# Extract legend from the first plot
legend <- get_legend(plots[[2]])

# Remove legends from all plots and remove y-tit from right most graphs
plots_no_legend <- lapply(plots, function(p) p + theme(legend.position = "none"))

plots_no_legend[[2]] <- plots_no_legend[[2]] + theme(axis.title.y = element_blank())
plots_no_legend[[4]] <- plots_no_legend[[4]] + theme(axis.title.y = element_blank())
plots_no_legend[[1]] <- plots_no_legend[[1]] + theme(axis.title.x = element_blank())
plots_no_legend[[2]] <- plots_no_legend[[2]] + theme(axis.title.x = element_blank())

# Remove the y-axis for 2 and 4
plots_no_legend[[2]] <- plots_no_legend[[2]] +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

plots_no_legend[[4]] <- plots_no_legend[[4]] +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())


# Combine plots without legends in a grid (patchwork)
plot_grid <- wrap_plots(plots_no_legend, ncol = 2, nrow = 2)

# Now combine plot grid and legend grob side-by-side using cowplot::plot_grid()
final_plot <- cowplot::plot_grid(
  plot_grid, 
  legend, 
  rel_widths = c(4, 1), 
  ncol = 2,
  align = "h"
)

# save plot
plotPath <- paste0("./lefseHeatmap_top25LDA.pdf")
ggsave(
  filename = plotPath,
  plot = final_plot,
  width = 22,
  height = 24,
  dpi = 800
)

lefsePlot <- final_plot
```
